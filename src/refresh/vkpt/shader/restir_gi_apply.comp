/*
Copyright (C) 2024

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

// ========================================================================== //
// ReSTIR GI Apply
//
// Takes the final resampled GI reservoir and applies the indirect illumination
// contribution to the path tracer output. This adds to the existing indirect
// lighting rather than replacing it, acting as a resampled supplementary signal.
// ========================================================================== //

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#define GLOBAL_UBO_DESC_SET_IDX 0
#include "global_ubo.h"

#define GLOBAL_TEXTURES_DESC_SET_IDX 1
#include "global_textures.h"

#include "utils.glsl"
#include "restir_gi.glsl"

void main()
{
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    
    if (ipos.x >= global_ubo.width || ipos.y >= global_ubo.height)
        return;
    
    int debugView = int(global_ubo.pt_restir_gi_debug_view);

    // Debug view 20: Show bounce distance from VIEW_DIRECTION2.w
    if (debugView == 20)
    {
        vec4 bounceData = texelFetch(TEX_PT_VIEW_DIRECTION2, ipos, 0);
        float bounceDistance = bounceData.w;
        vec3 debugColor;
        if (bounceDistance < 0.001)
            debugColor = vec3(1.0, 0.0, 0.0);  // Red = no bounce data
        else
            debugColor = vec3(0.0, 1.0, 0.0) * clamp(bounceDistance * 0.01, 0.0, 1.0);  // Green = has bounce
        imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(debugColor * STORAGE_SCALE_HF)));
        return;
    }

    // Debug view 21: Show radiance luminance from BOUNCE_THROUGHPUT.w
    if (debugView == 21)
    {
        float radLuminance = texelFetch(TEX_PT_BOUNCE_THROUGHPUT, ipos, 0).w;
        vec3 debugColor;
        if (radLuminance < 0.001)
            debugColor = vec3(0.0, 0.0, 1.0);  // Blue = no radiance
        else
            debugColor = vec3(radLuminance * 0.5);  // Grayscale = radiance luminance
        imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(debugColor * STORAGE_SCALE_HF)));
        return;
    }

    // Debug view 22: Show secondary surface normal from GEO_NORMAL2
    if (debugView == 22)
    {
        vec3 normal = decode_normal(texelFetch(TEX_PT_GEO_NORMAL2, ipos, 0).x);
        vec3 debugColor = normal * 0.5 + 0.5;  // Map -1..1 to 0..1
        imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(debugColor * STORAGE_SCALE_HF)));
        return;
    }
    
    // Check if ReSTIR GI is enabled
    if (global_ubo.pt_restir_gi_enable == 0)
        return;

    // Debug view 10: shader running + GI enabled (red tint)
    if (debugView == 10)
    {
        vec3 debugColor = vec3(0.2, 0.0, 0.0) * STORAGE_SCALE_HF;
        imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(debugColor)));
        return;
    }

    // Debug view 30: Show weight value from reservoir
    if (debugView == 30)
    {
        uvec4 weightData = imageLoad(IMG_PT_RESTIR_GI_WEIGHT_A, ipos);
        float w = uintBitsToFloat(weightData.x);
        vec3 debugColor;
        if (isnan(w) || isinf(w))
            debugColor = vec3(1.0, 0.0, 1.0);  // Magenta = NaN/Inf
        else if (w <= 0.0)
            debugColor = vec3(1.0, 0.0, 0.0);  // Red = zero/negative weight
        else if (w < 0.1)
            debugColor = vec3(0.0, 0.0, 1.0);  // Blue = very small weight
        else if (w > 100.0)
            debugColor = vec3(1.0, 1.0, 0.0);  // Yellow = huge weight
        else
            debugColor = vec3(0.0, 1.0, 0.0) * clamp(w, 0.0, 1.0);  // Green = reasonable
        imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(debugColor * STORAGE_SCALE_HF)));
        return;
    }
    
    // -------------------------------------------------------------------------
    // Load surface data
    // -------------------------------------------------------------------------
    
    vec4 pos_mat = texelFetch(TEX_PT_SHADING_POSITION, ipos, 0);
    vec3 surfacePos = pos_mat.xyz;
    uint material_id = floatBitsToUint(pos_mat.w);
    
    if (material_id == 0)
        return;
    
    vec3 surfaceNormal = decode_normal(texelFetch(TEX_PT_NORMAL_A, ipos, 0).x);
    vec4 baseColor = texelFetch(TEX_PT_BASE_COLOR_A, ipos, 0);
    vec3 albedo = baseColor.rgb;
    
    // -------------------------------------------------------------------------
    // Load final resampled reservoir (from A buffer - current frame result)
    // -------------------------------------------------------------------------
    
    RestirGIReservoir reservoir = restirGI_loadReservoirA(ipos);
    
    // Skip invalid reservoirs
    if (!restirGI_isValid(reservoir) || reservoir.weightSum <= 0.0)
        return;

    // Clamp weight to prevent extreme values from numerical issues
    // A properly normalized reservoir should have weight close to 1.0
    float weight = clamp(reservoir.weightSum, 0.0, 10.0);

    // -------------------------------------------------------------------------
    // Compute GI contribution
    // -------------------------------------------------------------------------

    vec3 toSample = reservoir.position - surfacePos;
    float dist2 = dot(toSample, toSample);
    
    if (dist2 < 1e-6)
        return;
    
    vec3 L = toSample * inversesqrt(dist2);
    float NdotL = max(0.0, dot(surfaceNormal, L));
    
    if (NdotL <= 0.0)
        return;
    
    // Lambertian BRDF
    vec3 brdf = albedo / M_PI;
    
    // GI contribution = radiance * brdf * geometry term * reservoir weight
    // The reservoir weight already contains 1/pdf, so this gives us the properly
    // weighted Monte Carlo estimate
    vec3 giContrib = reservoir.radiance * brdf * NdotL * weight;

    // NaN/Inf protection
    if (any(isnan(giContrib)) || any(isinf(giContrib)))
        return;

    // Clamp to prevent fireflies
    float maxLum = 10.0;
    float lum = luminance(giContrib);
    if (lum > maxLum)
    {
        giContrib *= maxLum / lum;
    }

    // Additional safety clamp
    giContrib = max(giContrib, vec3(0.0));
    
    // -------------------------------------------------------------------------
    // Debug view options
    // -------------------------------------------------------------------------
    
    if (debugView == 1)
    {
        // Show reservoir weight
        float w = clamp(reservoir.weightSum * 0.1, 0.0, 1.0);
        giContrib = vec3(w, w * 0.5, 0.0);
    }
    else if (debugView == 2)
    {
        // Show M value (sample count)
        float m = float(reservoir.M) / float(global_ubo.pt_restir_gi_max_history);
        giContrib = vec3(m, 1.0 - m, 0.0);
    }
    else if (debugView == 3)
    {
        // Show reservoir age
        float age = float(reservoir.age) / float(global_ubo.pt_restir_gi_max_reservoir_age);
        giContrib = vec3(0.0, 1.0 - age, age);
    }
    else if (debugView == 4)
    {
        // Show sample radiance
        giContrib = reservoir.radiance * 0.1;
    }
    else if (debugView == 5)
    {
        // Show sample normal
        giContrib = reservoir.normal * 0.5 + 0.5;
    }
    
    // -------------------------------------------------------------------------
    // Add GI contribution to the low-frequency color buffer
    // This is additive - the base indirect lighting is already there
    // -------------------------------------------------------------------------
    
    if (debugView == 0)
    {
        giContrib *= STORAGE_SCALE_LF;
        
        // Load existing LF color and add GI contribution
        SH existingLF = load_SH(TEX_PT_COLOR_LF_SH, TEX_PT_COLOR_LF_COCG, ipos);
        
        // Add as omnidirectional contribution (SH band 0)
        existingLF.shY.xyz += giContrib;
        
        // Store updated color
        STORE_SH(IMG_PT_COLOR_LF_SH, IMG_PT_COLOR_LF_COCG, ipos, existingLF);
    }
    else
    {
        // Debug views: write directly to HF for immediate visibility
        giContrib *= STORAGE_SCALE_HF;
        imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(giContrib)));
    }
}
