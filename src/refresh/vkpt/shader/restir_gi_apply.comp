/*
Copyright (C) 2024

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

// ========================================================================== //
// ReSTIR GI Apply
//
// Takes the final resampled GI reservoir and applies the indirect illumination
// contribution to the path tracer output. This adds to the existing indirect
// lighting rather than replacing it, acting as a resampled supplementary signal.
// ========================================================================== //

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#define GLOBAL_UBO_DESC_SET_IDX 0
#include "global_ubo.h"

#define GLOBAL_TEXTURES_DESC_SET_IDX 1
#include "global_textures.h"

#include "utils.glsl"
#include "restir_gi.glsl"

void main()
{
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    
    if (ipos.x >= global_ubo.width || ipos.y >= global_ubo.height)
        return;
    
    // Check if ReSTIR GI is enabled
    if (global_ubo.pt_restir_gi_enable == 0)
        return;
    
    int debugView = int(global_ubo.pt_restir_gi_debug_view);
    
    // Debug view 10: just show that the shader is running (red tint)
    if (debugView == 10)
    {
        vec3 debugColor = vec3(0.2, 0.0, 0.0) * STORAGE_SCALE_HF;
        imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(debugColor)));
        return;
    }
    
    // -------------------------------------------------------------------------
    // Load surface data
    // -------------------------------------------------------------------------
    
    vec4 pos_mat = texelFetch(TEX_PT_SHADING_POSITION, ipos, 0);
    vec3 surfacePos = pos_mat.xyz;
    uint material_id = floatBitsToUint(pos_mat.w);
    
    if (material_id == 0)
        return;
    
    vec3 surfaceNormal = decode_normal(texelFetch(TEX_PT_NORMAL_A, ipos, 0).x);
    vec4 baseColor = texelFetch(TEX_PT_BASE_COLOR_A, ipos, 0);
    vec3 albedo = baseColor.rgb;
    
    // -------------------------------------------------------------------------
    // Load final resampled reservoir (from A buffer - current frame result)
    // -------------------------------------------------------------------------
    
    RestirGIReservoir reservoir = restirGI_loadReservoirA(ipos);
    
    // Skip invalid reservoirs
    if (!restirGI_isValid(reservoir) || reservoir.weightSum <= 0.0)
        return;
    
    // -------------------------------------------------------------------------
    // Compute GI contribution
    // -------------------------------------------------------------------------
    
    vec3 toSample = reservoir.position - surfacePos;
    float dist2 = dot(toSample, toSample);
    
    if (dist2 < 1e-6)
        return;
    
    vec3 L = toSample * inversesqrt(dist2);
    float NdotL = max(0.0, dot(surfaceNormal, L));
    
    if (NdotL <= 0.0)
        return;
    
    // Lambertian BRDF
    vec3 brdf = albedo / M_PI;
    
    // GI contribution = radiance * brdf * geometry term * reservoir weight
    // The reservoir weight already contains 1/pdf, so this gives us the properly
    // weighted Monte Carlo estimate
    vec3 giContrib = reservoir.radiance * brdf * NdotL * reservoir.weightSum;
    
    // Clamp to prevent fireflies
    float maxLum = 10.0;
    float lum = luminance(giContrib);
    if (lum > maxLum)
    {
        giContrib *= maxLum / lum;
    }
    
    // -------------------------------------------------------------------------
    // Debug view options
    // -------------------------------------------------------------------------
    
    if (debugView == 1)
    {
        // Show reservoir weight
        float w = clamp(reservoir.weightSum * 0.1, 0.0, 1.0);
        giContrib = vec3(w, w * 0.5, 0.0);
    }
    else if (debugView == 2)
    {
        // Show M value (sample count)
        float m = float(reservoir.M) / float(global_ubo.pt_restir_gi_max_history);
        giContrib = vec3(m, 1.0 - m, 0.0);
    }
    else if (debugView == 3)
    {
        // Show reservoir age
        float age = float(reservoir.age) / float(global_ubo.pt_restir_gi_max_reservoir_age);
        giContrib = vec3(0.0, 1.0 - age, age);
    }
    else if (debugView == 4)
    {
        // Show sample radiance
        giContrib = reservoir.radiance * 0.1;
    }
    else if (debugView == 5)
    {
        // Show sample normal
        giContrib = reservoir.normal * 0.5 + 0.5;
    }
    
    // -------------------------------------------------------------------------
    // Add GI contribution to the low-frequency color buffer
    // This is additive - the base indirect lighting is already there
    // -------------------------------------------------------------------------
    
    if (debugView == 0)
    {
        giContrib *= STORAGE_SCALE_LF;
        
        // Load existing LF color and add GI contribution
        SH existingLF = load_SH(TEX_PT_COLOR_LF_SH, TEX_PT_COLOR_LF_COCG, ipos);
        
        // Add as omnidirectional contribution (SH band 0)
        existingLF.shY.xyz += giContrib;
        
        // Store updated color
        STORE_SH(IMG_PT_COLOR_LF_SH, IMG_PT_COLOR_LF_COCG, ipos, existingLF);
    }
    else
    {
        // Debug views: write directly to HF for immediate visibility
        giContrib *= STORAGE_SCALE_HF;
        imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(giContrib)));
    }
}
