/*
Copyright (C) 2024

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

// ========================================================================== //
// ReSTIR GI Temporal Resampling
//
// Reads initial GI samples from the path tracer output, reprojects the 
// previous frame's reservoir, and performs temporal reservoir combination.
// ========================================================================== //

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#define GLOBAL_UBO_DESC_SET_IDX 0
#include "global_ubo.h"

#define GLOBAL_TEXTURES_DESC_SET_IDX 1
#include "global_textures.h"

#include "utils.glsl"
#include "tiny_encryption_algorithm.h"
#include "restir_gi.glsl"

// RNG for temporal resampling using TEA
uvec2 rng_state;

uint tea_hash(uint x)
{
    uvec2 result = encrypt_tea(uvec2(x, 0x12345678u));
    return result.x ^ result.y;
}

float get_rng_local(uint dimension)
{
    rng_state = encrypt_tea(uvec2(rng_state.x, rng_state.y + dimension));
    return float(rng_state.x) / float(0xFFFFFFFFu);
}

void main()
{
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
    
    if (ipos.x >= global_ubo.width || ipos.y >= global_ubo.height)
        return;
    
    // Check if ReSTIR GI is enabled
    if (global_ubo.pt_restir_gi_enable == 0)
    {
        // Store empty reservoir
        RestirGIReservoir emptyRes = restirGI_emptyReservoir();
        restirGI_storeReservoirA(ipos, emptyRes);
        return;
    }
    
    // Initialize RNG
    rng_state = encrypt_tea(uvec2(ipos.x | (ipos.y << 16), global_ubo.current_frame_idx));
    
    // -------------------------------------------------------------------------
    // Load current frame's G-buffer data
    // -------------------------------------------------------------------------
    
    vec4 pos_mat = texelFetch(TEX_PT_SHADING_POSITION, ipos, 0);
    vec3 currentPos = pos_mat.xyz;
    uint material_id = floatBitsToUint(pos_mat.w);
    
    // No valid surface - store empty reservoir
    if (material_id == 0)
    {
        RestirGIReservoir emptyRes = restirGI_emptyReservoir();
        restirGI_storeReservoirA(ipos, emptyRes);
        return;
    }
    
    vec3 currentNormal = decode_normal(texelFetch(TEX_PT_NORMAL_A, ipos, 0).x);
    vec3 currentGeoNormal = decode_normal(texelFetch(TEX_PT_GEO_NORMAL_A, ipos, 0).x);
    float currentDepth = texelFetch(TEX_PT_VIEW_DEPTH_A, ipos, 0).x;
    
    // -------------------------------------------------------------------------
    // Load the current frame's GI sample from path tracer bounce output
    // The bounce ray creates an initial GI sample
    // -------------------------------------------------------------------------
    
    // Read secondary surface data from bounce pass output
    vec4 giSamplePosData = texelFetch(TEX_PT_RESTIR_GI_POS_A, ipos, 0);
    vec3 giSamplePos = giSamplePosData.xyz;
    
    // Check if we have a valid GI sample
    bool hasValidSample = (length(giSamplePos - currentPos) > 0.001);
    
    // Create initial reservoir from current sample
    RestirGIReservoir currentReservoir = restirGI_emptyReservoir();
    
    if (hasValidSample)
    {
        // Load packed normal and radiance from the GI reservoir buffer
        uvec4 normRadData = texelFetch(TEX_PT_RESTIR_GI_NORM_RAD_A, ipos, 0);
        vec3 giSampleNormal = decodeNormalOct(normRadData.x);
        vec3 giSampleRadiance = decodeRadianceLogLuv(normRadData.y);
        
        if (luminance(giSampleRadiance) > 0.0)
        {
            // Initial sample with unit weight (uniform sampling)
            float initialPdf = 1.0;  // Uniform hemisphere sampling pdf cancels out
            currentReservoir = restirGI_makeReservoir(giSamplePos, giSampleNormal, giSampleRadiance, initialPdf);
        }
    }
    
    // -------------------------------------------------------------------------
    // Temporal resampling - reproject and combine with previous frame
    // -------------------------------------------------------------------------
    
    RestirGIReservoir outputReservoir = currentReservoir;
    
    if (global_ubo.pt_restir_gi_temporal != 0)
    {
        // Reproject current position to previous frame
        vec4 motion = texelFetch(TEX_PT_MOTION, ipos, 0);
        ivec2 prevPos = ivec2(ipos + motion.xy + 0.5);
        
        // Check if reprojection is valid
        bool validReproject = (prevPos.x >= 0 && prevPos.x < global_ubo.width &&
                               prevPos.y >= 0 && prevPos.y < global_ubo.height);
        
        if (validReproject)
        {
            // Load previous frame's G-buffer for validation
            vec4 prevPosMat = texelFetch(TEX_PT_SHADING_POSITION, prevPos, 0);
            vec3 prevSurfacePos = prevPosMat.xyz;
            uint prevMaterial = floatBitsToUint(prevPosMat.w);
            
            if (prevMaterial != 0)
            {
                vec3 prevNormal = decode_normal(texelFetch(TEX_PT_NORMAL_B, prevPos, 0).x);
                float prevDepth = texelFetch(TEX_PT_VIEW_DEPTH_B, prevPos, 0).x;
                
                // Check surface similarity
                bool surfaceMatch = restirGI_areSurfacesSimilar(
                    currentNormal, prevNormal,
                    currentDepth, prevDepth,
                    global_ubo.pt_restir_gi_normal_threshold,
                    global_ubo.pt_restir_gi_depth_threshold);
                
                if (surfaceMatch)
                {
                    // Load previous frame's reservoir
                    RestirGIReservoir prevReservoir = restirGI_loadReservoirB(prevPos);
                    
                    // Age check - discard old reservoirs
                    if (prevReservoir.M > 0 && prevReservoir.age < global_ubo.pt_restir_gi_max_reservoir_age)
                    {
                        // Calculate target PDF for the previous sample at current surface
                        float targetPdf = restirGI_getTargetPdf(
                            prevReservoir.position,
                            prevReservoir.radiance,
                            currentPos,
                            currentNormal);
                        
                        // Calculate Jacobian for domain transformation
                        float jacobian = restirGI_calculateJacobian(currentPos, prevSurfacePos, prevReservoir);
                        
                        if (restirGI_validateJacobian(jacobian) && targetPdf > 0.0)
                        {
                            // Clamp M to prevent over-accumulation
                            uint maxHistory = uint(global_ubo.pt_restir_gi_max_history);
                            uint clampedM = min(prevReservoir.M, maxHistory);
                            
                            RestirGIReservoir tempPrev = prevReservoir;
                            tempPrev.M = clampedM;
                            tempPrev.weightSum *= (jacobian * float(clampedM)) / float(prevReservoir.M);
                            
                            // Combine reservoirs
                            float rng = get_rng_local(0);
                            restirGI_combineReservoirs(outputReservoir, tempPrev, rng, targetPdf);
                        }
                    }
                }
            }
        }
    }
    
    // Finalize the reservoir
    if (outputReservoir.M > 0)
    {
        float targetPdf = restirGI_getTargetPdf(
            outputReservoir.position,
            outputReservoir.radiance,
            currentPos,
            currentNormal);
        
        restirGI_finalizeResampling(outputReservoir, 1.0, targetPdf * float(outputReservoir.M));
        
        // Increment age
        outputReservoir.age++;
    }
    
    // Store output reservoir
    restirGI_storeReservoirA(ipos, outputReservoir);
}
