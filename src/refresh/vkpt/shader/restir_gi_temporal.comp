/*
Copyright (C) 2024

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
*/

// ========================================================================== //
// ReSTIR GI Temporal Resampling
//
// Reads initial GI samples from the path tracer output, reprojects the 
// previous frame's reservoir, and performs temporal reservoir combination.
// ========================================================================== //

#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

#define GLOBAL_UBO_DESC_SET_IDX 0
#include "global_ubo.h"

#define GLOBAL_TEXTURES_DESC_SET_IDX 1
#include "global_textures.h"

#include "utils.glsl"
#include "tiny_encryption_algorithm.h"
#include "restir_gi.glsl"

// RNG for temporal resampling using TEA
uvec2 rng_state;

uint tea_hash(uint x)
{
    uvec2 result = encrypt_tea(uvec2(x, 0x12345678u));
    return result.x ^ result.y;
}

float get_rng_local(uint dimension)
{
    rng_state = encrypt_tea(uvec2(rng_state.x, rng_state.y + dimension));
    return float(rng_state.x) / float(0xFFFFFFFFu);
}

void main()
{
    ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);

    if (ipos.x >= global_ubo.width || ipos.y >= global_ubo.height)
        return;

    // Debug views 20+ need raw data from indirect_lighting.rgen - pass through
    int debugView = int(global_ubo.pt_restir_gi_debug_view);
    if (debugView >= 20)
        return;

    // Check if ReSTIR GI is enabled
    if (global_ubo.pt_restir_gi_enable == 0)
    {
        // Store empty reservoir
        RestirGIReservoir emptyRes = restirGI_emptyReservoir();
        restirGI_storeReservoirA(ipos, emptyRes);
        return;
    }
    
    // Initialize RNG
    rng_state = encrypt_tea(uvec2(ipos.x | (ipos.y << 16), global_ubo.current_frame_idx));
    
    // -------------------------------------------------------------------------
    // Load current frame's G-buffer data
    // -------------------------------------------------------------------------
    
    vec4 pos_mat = texelFetch(TEX_PT_SHADING_POSITION, ipos, 0);
    vec3 currentPos = pos_mat.xyz;
    uint material_id = floatBitsToUint(pos_mat.w);
    
    // No valid surface - store empty reservoir
    if (material_id == 0)
    {
        RestirGIReservoir emptyRes = restirGI_emptyReservoir();
        restirGI_storeReservoirA(ipos, emptyRes);
        return;
    }
    
    vec3 currentNormal = decode_normal(texelFetch(TEX_PT_NORMAL_A, ipos, 0).x);
    vec3 currentGeoNormal = decode_normal(texelFetch(TEX_PT_GEO_NORMAL_A, ipos, 0).x);
    float currentDepth = texelFetch(TEX_PT_VIEW_DEPTH_A, ipos, 0).x;
    
    // -------------------------------------------------------------------------
    // Load the current frame's GI sample from path tracer bounce output
    // The bounce ray creates an initial GI sample stored in working G-buffer:
    // - VIEW_DIRECTION2: bounce direction (xyz) and hit distance (w)
    // - GEO_NORMAL2: secondary surface normal
    // - BOUNCE_THROUGHPUT.w: radiance luminance
    // -------------------------------------------------------------------------

    // Read bounce direction and distance from VIEW_DIRECTION2
    vec4 bounceData = texelFetch(TEX_PT_VIEW_DIRECTION2, ipos, 0);
    vec3 bounceDirection = bounceData.xyz;
    float bounceDistance = bounceData.w;

    // Check if we have a valid GI sample (distance > 0 means valid hit)
    bool hasValidSample = (bounceDistance > 0.001);

    // Create initial reservoir from current sample
    RestirGIReservoir currentReservoir = restirGI_emptyReservoir();

    if (hasValidSample)
    {
        // Reconstruct secondary surface position
        vec3 giSamplePos = currentPos + bounceDirection * bounceDistance;

        // Load secondary surface normal from GEO_NORMAL2
        vec3 giSampleNormal = decode_normal(texelFetch(TEX_PT_GEO_NORMAL2, ipos, 0).x);

        // Load radiance luminance from BOUNCE_THROUGHPUT.w
        float radLuminance = texelFetch(TEX_PT_BOUNCE_THROUGHPUT, ipos, 0).w;

        // Reconstruct approximate radiance (grayscale based on luminance)
        // TODO: For better color accuracy, store full RGB radiance in indirect_lighting.rgen
        // Currently using luminance only, which works for importance sampling but loses color
        // information. Full RGB storage would require additional texture binding.
        // Lumen stores RGB16F radiance for better quality - see restirgi_commons.glsl
        vec3 giSampleRadiance = vec3(radLuminance);

        if (radLuminance > 0.0)
        {
            // Initial sample with unit source PDF (uniform hemisphere sampling)
            float sourcePdf = 1.0;
            currentReservoir = restirGI_makeReservoir(giSamplePos, giSampleNormal, giSampleRadiance, sourcePdf);

            // CRITICAL: Convert weightSum to RIS weight = targetPdf * (1/sourcePdf)
            // This is needed because combineReservoirs expects weightSum to already include targetPdf
            float initialTargetPdf = restirGI_getTargetPdf(giSamplePos, giSampleRadiance, currentPos, currentNormal);
            currentReservoir.weightSum *= initialTargetPdf;
        }
    }
    
    // -------------------------------------------------------------------------
    // Temporal resampling - reproject and combine with previous frame
    // -------------------------------------------------------------------------
    
    RestirGIReservoir outputReservoir = currentReservoir;
    
    if (global_ubo.pt_restir_gi_temporal != 0)
    {
        // Reproject current position to previous frame
        vec4 motion = texelFetch(TEX_PT_MOTION, ipos, 0);
        ivec2 prevPos = ivec2(ipos + motion.xy + 0.5);
        
        // Check if reprojection is valid
        bool validReproject = (prevPos.x >= 0 && prevPos.x < global_ubo.width &&
                               prevPos.y >= 0 && prevPos.y < global_ubo.height);
        
        if (validReproject)
        {
            // Load previous frame's G-buffer for validation
            vec4 prevPosMat = texelFetch(TEX_PT_SHADING_POSITION, prevPos, 0);
            vec3 prevSurfacePos = prevPosMat.xyz;
            uint prevMaterial = floatBitsToUint(prevPosMat.w);
            
            if (prevMaterial != 0)
            {
                vec3 prevNormal = decode_normal(texelFetch(TEX_PT_NORMAL_B, prevPos, 0).x);
                float prevDepth = texelFetch(TEX_PT_VIEW_DEPTH_B, prevPos, 0).x;

                // Check surface similarity including material type
                // This follows Lumen's pattern to prevent GI bleeding between different material types
                bool surfaceMatch = restirGI_areSurfacesSimilarWithMaterial(
                    currentNormal, prevNormal,
                    currentDepth, prevDepth,
                    material_id, prevMaterial,
                    global_ubo.pt_restir_gi_normal_threshold,
                    global_ubo.pt_restir_gi_depth_threshold);
                
                if (surfaceMatch)
                {
                    // Load previous frame's reservoir
                    RestirGIReservoir prevReservoir = restirGI_loadReservoirB(prevPos);
                    
                    // Age check - discard old reservoirs
                    if (prevReservoir.M > 0 && prevReservoir.age < global_ubo.pt_restir_gi_max_reservoir_age)
                    {
                        // Calculate target PDF for the previous sample at current surface
                        float targetPdf = restirGI_getTargetPdf(
                            prevReservoir.position,
                            prevReservoir.radiance,
                            currentPos,
                            currentNormal);
                        
                        // Calculate Jacobian for domain transformation
                        float jacobian = restirGI_calculateJacobian(currentPos, prevSurfacePos, prevReservoir);
                        
                        if (restirGI_validateJacobian(jacobian) && targetPdf > 0.0)
                        {
                            // TODO: Add visibility validation via ray query
                            // Ideally we would trace a shadow ray from currentPos to prevReservoir.position
                            // to verify the GI sample is actually visible from the current surface.
                            // This requires VK_KHR_ray_query extension in compute shaders.
                            // For now, we rely on surface similarity checks and Jacobian validation
                            // to filter out most invalid reuse cases.

                            // Clamp M to prevent over-accumulation
                            uint maxHistory = uint(global_ubo.pt_restir_gi_max_history);
                            uint clampedM = min(prevReservoir.M, maxHistory);

                            RestirGIReservoir tempPrev = prevReservoir;
                            tempPrev.M = clampedM;
                            // Only apply Jacobian - M clamping is handled by combineReservoirs
                            // which multiplies by tempPrev.M internally
                            tempPrev.weightSum *= jacobian;

                            // Combine reservoirs
                            float rng = get_rng_local(0);
                            restirGI_combineReservoirs(outputReservoir, tempPrev, rng, targetPdf);
                        }
                    }
                }
            }
        }
    }
    
    // Finalize the reservoir
    if (outputReservoir.M > 0)
    {
        float targetPdf = restirGI_getTargetPdf(
            outputReservoir.position,
            outputReservoir.radiance,
            currentPos,
            currentNormal);
        
        restirGI_finalizeResampling(outputReservoir, 1.0, targetPdf * float(outputReservoir.M));
        
        // Increment age
        outputReservoir.age++;
    }
    
    // Store output reservoir
    restirGI_storeReservoirA(ipos, outputReservoir);
}
